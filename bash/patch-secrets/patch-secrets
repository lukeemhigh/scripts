#!/usr/bin/env bash
#
# Patches Kubernetes TLS secrets with new certificate and key files.
#
# Author Luca Giugliardi
# Email: <lukeemhigh+dev@protonmail.com>

# ----------------------------- Shell Options ---------------------------- #

set -o pipefail

# ------------------------------- Functions ------------------------------ #

get_lib_path() {
  local lib_path
  lib_path=$(cd "$(dirname "$0")" && echo "${PWD}" | sed 's/\/[^/]*$/\/lib/')
  echo "${lib_path}"
}

print_usage() {
  cat <<EOF
Usage: $0 [OPTIONS] [ARGUMENTS]

Options:
  -c, --cert <path>
          Path to the certificate file

  -k, --key <path>
          Path to the key file

  -p, --pattern <regex>
          Pattern that will be used to match the desired
          secrets.

  -h, --help
          Show this help.
EOF
}

parse_args() {
  local TEMP
  TEMP=$(getopt -o c:k:p:h --long cert:,key:,pattern:,help -n 'patch-secrets' -- "$@")

  if [ $? -ne 0 ]; then
    print_usage 1>&2
    exit 1
  fi

  eval set -- "$TEMP"

  while true; do
    case "$1" in
      -c | --cert)
        cert_file="$2"
        shift 2
        ;;
      -k | --key)
        key_file="$2"
        shift 2
        ;;
      -p | --pattern)
        pattern="$2"
        shift 2
        ;;
      -h | --help)
        print_usage
        exit 0
        ;;
      --)
        shift
        break
        ;;
      *)
        print_usage 1>&2
        exit 1
        ;;
    esac
  done
}

get_secrets() {
  local pattern
  pattern="$1"

  kubectl get secrets -A |
    grep -oP "${pattern}"
}

get_k8s_resources() {
  local kind="$1"
  local ns_part="$2"
  local name_part="$3"
  local pattern=".*-${ns_part}.*${name_part}"

  kubectl get "${kind}" -A |
    grep -oP "${pattern}"
}

patch_secrets() {
  local namespace="$1"
  local secret="$2"

  local payload="{\"data\":{\"tls.crt\":\"${b64_cert}\",\"tls.key\":\"${b64_key}\"}}"

  log info "Patching secret ${namespace}/${secret}..."

  if kubectl -n "${namespace}" patch secret "${secret}" --type='merge' -p="${payload}" >/dev/null 2>&1; then
    log info "Secret ${namespace}/${secret} patched successfully."
  else
    local exit_code=$?
    log warn "Failed to patch secret ${namespace}/${secret}: command failed with exit code ${exit_code}"
  fi
}
export -f patch_secrets

main() {
  local tempfile
  local b64_cert
  local b64_key
  local cert_file
  local key_file
  local pattern

  parse_args "$@"

  check_utils "kubectl" "parallel"

  tempfile=$(mktemp -t k8s-secrets.XXXXXXXX --suffix .txt --tmpdir="${HOME}/tmp")
  trap 'rm -f "${tempfile}"' INT TERM EXIT

  if [[ ! -f "${tempfile}" ]]; then
    log error "Failed to create tempfile ${tempfile}"
    exit 1
  fi

  if [[ ! -f "${cert_file}" ]]; then
    log error "Unable to locate certificate file: ${cert_file}"
    exit 1
  fi

  if [[ ! -f "${key_file}" ]]; then
    log error "Unable to locate key file: ${key_file}"
    exit 1
  fi

  log info "Fetching secrets matching pattern ${pattern}..."
  get_secrets "${pattern}" | awk '{print $1 "\t" $2}' >"${tempfile}"

  if [[ "$(wc -l <"${tempfile}")" -eq 0 ]]; then
    log info "No secrets found matching provided search pattern: ${pattern}."
    exit 0
  fi

  log info "Found the following secrets:"
  printf "\n"
  cat "${tempfile}" | column -t -N 'NAMESPACE,SECRET NAME'
  printf "\n"

  read -r -p "Do you want to proceed with patching these secrets? [Y/n] " response
  case "$response" in
    [yY][eE][sS] | [yY])
      log info "Proceeding with patching..."
      ;;
    *)
      log info "Operation cancelled by user."
      exit 0
      ;;
  esac

  b64_cert="$(base64 <"${cert_file}" | tr -d '\n')"
  b64_key="$(base64 <"${key_file}" | tr -d '\n')"

  export b64_cert b64_key

  parallel -j 4 \
    --halt now,fail=1 \
    --colsep '\t' \
    --env b64_cert \
    --env b64_key \
    'patch_secrets {1} {2}' \
    :::: "${tempfile}"
}

lib_path=$(get_lib_path)

# shellcheck disable=1091
source "${lib_path}/log.sh"
export -f log

# shellcheck disable=1091
source "${lib_path}/check-utils.sh"

main "$@"
