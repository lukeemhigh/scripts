#!/usr/bin/env bash
#
# Patches Kubernetes TLS secrets with new certificate and key files.
#
# Author Luca Giugliardi
# Email: <lukeemhigh+dev@protonmail.com>

# ----------------------------- Shell Options ---------------------------- #

set -o pipefail

# ------------------------------- Functions ------------------------------ #

print_usage() {
  cat <<EOF
Usage: $0 [OPTIONS] [ARGUMENTS]

Options:
  -c, --cert <path>
          Path to the certificate file

  -k, --key <path>
          Path to the key file

  -p, --pattern <regex>
          Pattern that will be used to match the desired
          secrets.

  -h, --help
          Show this help.
EOF
  exit 1
}

get_lib_path() {
  local lib_path
  lib_path=$(cd "$(dirname "$0")" && echo "${PWD}" | sed 's/\/[^/]*$/\/lib/')
  echo "${lib_path}"
}

get_secrets() {
  local pattern
  pattern="$1"

  kubectl get secrets -A |
    grep -oP "${pattern}"
}

patch_secrets() {
  local namespace="$1"
  local secret="$2"

  local payload="{\"data\":{\"tls.crt\":\"${b64_cert}\",\"tls.key\":\"${b64_key}\"}}"

  log info "Patching secret ${namespace}/${secret}..."

  if kubectl -n "${namespace}" patch secret "${secret}" --type='merge' -p="${payload}"; then
    log info "Secret ${namespace}/${secret} patched successfully."
  else
    local exit_code=$?
    log warn "Failed to patch secret ${namespace}/${secret}: command failed with exit code ${exit_code}"
  fi
}
export -f patch_secrets

main() {
  local tempfile
  local b64_cert
  local b64_key
  local payload
  local cert_file="$1"
  local key_file="$2"
  local pattern="$3"

  check_utils "kubectl" "parallel"

  tempfile=$(mktemp -t k8s-secrets.XXXXXXXX --suffix .txt --tmpdir="${HOME}/tmp")
  trap 'rm -f "${tempfile}"' INT TERM EXIT

  if [[ ! -f "${tempfile}" ]]; then
    log error "Failed to create tempfile ${tempfile}"
    exit 1
  fi

  if [[ ! -f "${cert_file}" ]]; then
    log error "Unable to locate certificate file: ${cert_file}"
    exit 1
  fi

  if [[ ! -f "${key_file}" ]]; then
    log error "Unable to locate key file: ${key_file}"
    exit 1
  fi

  log info "Fetching matching secrets..."
  log info "Using the following pattern to match secrets: ${pattern}"
  get_secrets "${pattern}" | awk '{print $1 "\t" $2}' >"${tempfile}"

  if [[ "$(wc -l <"${tempfile}")" -eq 0 ]]; then
    log info "No secrets found matching provided search pattern."
    exit 0
  fi

  log info "Found the following secrets:"
  printf "\n"
  cat "${tempfile}" | column -t -N 'NAMESPACE,SECRET NAME'
  printf "\n"

  read -r -p "Do you want to proceed with patching these secrets? [y/N] " response
  case "$response" in
    [yY][eE][sS] | [yY])
      log info "Proceeding with patching..."
      ;;
    *)
      log info "Operation cancelled by user."
      exit 0
      ;;
  esac

  b64_cert="$(base64 <"${cert_file}" | tr -d '\n')"
  b64_key="$(base64 <"${key_file}" | tr -d '\n')"

  export b64_cert b64_key

  parallel -j 4 \
    --halt now,fail=1 \
    --colsep '\t' \
    --env b64_cert \
    --env b64_key \
    'patch_secrets {1} {2}' \
    :::: "${tempfile}"

}

# -------------------------------- Optargs ------------------------------- #

TEMP=$(getopt -o c:k:p:h --long cert:,key:,pattern:help -n 'patch-secrets' -- "$@")

if [ $? -ne 0 ]; then
  print_usage
fi

eval set -- "$TEMP"

while true; do
  case "$1" in
    -c | --cert)
      cert_file="$2"
      shift 2
      ;;
    -k | --key)
      key_file="$2"
      shift 2
      ;;
    -r | --regex)
      pattern="$2"
      shift 2
      ;;
    -p | --pattern)
      pattern="$2"
      shift 2
      ;;
    -h | --help)
      print_usage
      ;;
    --)
      shift
      break
      ;;
    *)
      print_usage
      ;;
  esac
done

lib_path=$(get_lib_path)

# shellcheck disable=1091
source "${lib_path}/log.sh"
export -f log

# shellcheck disable=1091
source "${lib_path}/check-utils.sh"

main "${cert_file}" "${key_file}" "${pattern}"
